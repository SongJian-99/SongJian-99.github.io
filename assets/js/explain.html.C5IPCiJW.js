import{_ as s}from"./plugin-vue_export-helper.DlAUqK2U.js";import{c as e,a as t,o as a}from"./app.C4VKiIAB.js";const l={};function n(h,i){return a(),e("div",null,i[0]||(i[0]=[t(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>由于工作中业务比较复杂，一条 SQL 查询语句通常会涉及多个表，加上某些表数据量庞大（百万、甚至千万），SQL 语句的执行效率就成为日常工作中重点关注的方面。同时作为后端开发人员，对 SQL 语句进行优化的能力也是必不可少的。</p><h2 id="explain-各字段含义" tabindex="-1"><a class="header-anchor" href="#explain-各字段含义"><span>Explain 各字段含义</span></a></h2><p><code>Explain</code> 关键字可以查看 SQL 语句（适用 SELECT、INSERT、UPDATE、DELETE）的执行计划，使用命令如下。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结果信息中包含一些重要字段，我们先来了解下这些字段分别代表什么含义。</p><table><thead><tr><th>字段</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>序列标识</td><td>SQL 执行时从各表读取数据的顺序（常用）</td></tr><tr><td>select_type</td><td>查询类型</td><td>SQL 语句的查询类型（常用）</td></tr><tr><td>table</td><td>表名</td><td>SQL 执行时涉及的表信息。可取值：1、表名（例如：user）2、&lt;derived<em>N</em>&gt;（N 是 id 值，例如：&lt;derived4&gt;）3、&lt;union<em>M</em>,<em>N</em>&gt;（M、N 是 id 值，例如：&lt;union1,2&gt;）（常用）</td></tr><tr><td>partitions</td><td>分区信息</td><td>如果不涉及分区表，该列值为 NULL。</td></tr><tr><td>type</td><td>连接类型</td><td>用来衡量 SQL 语句的查询效率（常用）</td></tr><tr><td>possible_keys</td><td>SQL 语句可能使用的索引</td><td>取值可以为一个、多个或者为 NULL（常用）</td></tr><tr><td>key</td><td>SQL 语句实际使用的索引</td><td>如果为 NULL，则表示未使用索引（常用）</td></tr><tr><td>key_len</td><td>索引使用的字节数</td><td>估计值，大致使用的字节数。值越小，索引的效率越高</td></tr><tr><td>ref</td><td>连接使用的列或常数</td><td>（参考）</td></tr><tr><td>rows</td><td>MySQL 估计要读取并检测的行数</td><td>（参考）</td></tr><tr><td>filtered</td><td>表示通过索引过滤的行百分比</td><td>（参考）</td></tr><tr><td>Extra</td><td>附加信息</td><td>用来优化 SQL 语句（常用）</td></tr></tbody></table><h3 id="id" tabindex="-1"><a class="header-anchor" href="#id"><span>id</span></a></h3><p>序列号，表示 MySQL 执行 SQL 语句时从各表读取数据的顺序。id 越大，执行优先级越高；id 相同的为一组，执行优先级按照由上到下的循序排列。在复杂的 SQL 语句中可以清晰查看 SQL 的执行顺序。</p><h3 id="select-type" tabindex="-1"><a class="header-anchor" href="#select-type"><span>select_type</span></a></h3><p>SQL 语句的查询类型。取值如下。</p><ul><li>SIMPLE：简单查询，不涉及子查询和关联查询。</li><li>PRIMARY：主查询（查询中包含子查询，最外层的查询为 PRIMARY）。</li><li>UNION：UNION 之后的查询。<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">union</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>DEPENDENT UNION：UNION 之后的查询，但依赖外部查询结果。</li><li>UNION RESULT：UNION 操作的结果。</li><li>SUBQUERY：子查询，通常出现在 select 和 where 语句中</li><li>DEPENDENT SUBQUERY：子查询，但依赖外部查询结果。</li><li>DERIVED：派生表，临时产生的虚拟表（不实际存在于数据库中）。</li><li>DEPENDENT DERIVED：派生表，但依赖外部查询结果。</li><li>MATERIALIZED：物化子查询。</li><li>UNCACHEABLE SUBQUERY：无法缓存结果的子查询，外部查询的每一行都需要子查询重新计算结果。</li><li>UNCACHEABLE UNION：UNION 之后的查询是无法缓存结果的子查询（UNCACHEABLE SUBQUERY）。</li></ul><h3 id="type" tabindex="-1"><a class="header-anchor" href="#type"><span>type</span></a></h3><p>连接类型。MySQL 优化器选择的查询方法，用来衡量 SQL 语句的查询效率。效率从高到低，取值如下。</p><ul><li><p>system：表中只有一行数据。const 类型的特例。</p></li><li><p>const：表中最多有一个匹配记录。通常情况下使用了主键索引或唯一索引。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  // 主键索引</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> phone </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;xxx&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  // 唯一索引</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>eq_ref：使用主键索引或唯一索引进行联表查询时，最多返回一条符合条件的记录。与 const 类型非常相似，区别是 eq_ef 通常出现在联表的情况下，而 const 通常出现在单表情况下。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">role</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">role_id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> role</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; // 用户角色一对多的情况</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>ref：使用非唯一索引查找和多表连接，会返回匹配某个单独值的所有行。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;xxx&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>fulltext：使用 fulltext 索引，没见过。</p></li><li><p>ref_or_null：类似 ref，但是包含了搜索 NULL 值的情况。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;xxx&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> or</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> is</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>index_merge：使用了索引合并的优化方法。</p><p>索引合并：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并。</p></li><li><p>unique_subquery：在特殊的子查询中用来替换 eq_ref 类型。MySQL 内部优化器的一个标识符，并不是 <code>Explain</code> 输出的标准字段。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">value</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> primary_key </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> xxx)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>index_subquery：类似 unique_subquery，但是查询的列是非唯一索引。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">value</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> key_column </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> xxx)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>range：检索给定范围的行。</p></li><li><p>index：表示只遍历索引树，不扫描数据行，只从索引树中获取数据。</p></li><li><p>ALL：全表扫描，没有使用索引。</p></li></ul><h3 id="extra" tabindex="-1"><a class="header-anchor" href="#extra"><span>Extra</span></a></h3><p>附加信息，MySQL 执行 SQL 语句的相关信息，是否使用临时表、文件排序等.</p><p><strong>性能好</strong></p><ul><li>Using index：查询的列被索引覆盖，并且 where 条件满足最左匹配原则。通过索引即可获取所需的数据，检索效率高（覆盖索引，避免回表）。</li><li>Using index Condition：查询的列未被索引覆盖，但 where 条件可以使用到索引。（需要回表查询数据，多个 where 条件时有索引下推优化）</li><li>Using MRR：多范围读取优化，减少磁盘随机访问的次数，提升数据检索的效率。</li><li>Using join buffer：MySQL 使用连接缓冲区来处理查询，优化查询性能。连接缓冲区用于存储连接操作的中间结果。</li><li>Using where Using index：查询的列被索引覆盖，并且 where 条件是索引列之一，但不是索引的前导列。（使用 where 条件过滤结果，又使用了覆盖索引来优化查询性能）</li></ul><p><strong>性能差</strong></p><ul><li><p>Distinct：MySQL 执行 distinct 操作过滤结果集中的重复记录，性能较差。</p><p><strong>优化：可以在入库前做唯一校验，保证数据库记录唯一，避免使用 distinct。</strong></p></li><li><p>Using temporary：MySQL 需要创建一个临时表来处理查询。一般发生在涉及到排序（<code>order by</code>）和分组（<code>group by</code>）的查询操作中。如果数据量较少，临时表会存放在内存中，数据检索速度尚可。如果数据量很大，内存中存不下，临时表则会存放在磁盘上，数据检索速度很慢。</p><p><strong>优化：1、为排序和分组字段建立索引。2、加内存，确保临时表能够装载到内存。</strong></p></li><li><p>Using filesort：MySQL 需要对结果集进行排序操作，但无法使用索引，必须在磁盘上创建一个临时文件来完成排序。</p><p><strong>优化：1、给排序字段添加索引。2、加内存，确保临时文件能够装载到内存。</strong></p></li><li><p>Using where：查询的列未被索引覆盖、where 条件非索引列或 where 条件不是索引的前导列。（没有使用索引，仅使用 where 条件过滤结果）</p><p><strong>优化：为条件字段建立索引</strong></p></li></ul><h2 id="实战优化思路" tabindex="-1"><a class="header-anchor" href="#实战优化思路"><span>实战优化思路</span></a></h2><p>了解了 Explain 各个字段的含义和使用，那么如何在实际工作中使用呢？</p><p>大部分查询性能差的 SQL 语句都存在索引设计不合理的问题，一个复合索引字段顺序的调整，查询效率就会天差地别。实际工作中具体要如何优化 SQL 语句并无绝对，因为受到业务、表、索引等多方面的影响，每条 SQL 语句优化的方法都不一样，但是大体思路都是差不多的。</p><ol><li>判断 SQL 语句是否使用索引（key 列和 type 列）。</li><li>确认 SQL 语句的查询类型和连接类型（select_type 列和 type 列），了解优化器选择的查询方法。</li><li>查看 Extra 列的附加信息，进一步了解 SQL 语句的执行细节。</li><li>配合 id 列和 table 列，了解 SQL 语句的执行流程，分析复杂 SQL 语句时常用。</li><li>根据掌握的信息进行优化。索引设计不合理的情况通过添加索引、调整复合索引字段的顺序（保证 where、order by、group by 字段为索引字段）或者使用索引相关命令（<code>force index</code>、<code>ignore index</code>）的方式基本就可以解决。对于复杂的 SQL 语句有时需要重写，结合实际业务，调整 SQL 语句的执行顺序，利用索引提升查询效率。</li></ol>`,25)]))}const p=s(l,[["render",n],["__file","explain.html.vue"]]),k=JSON.parse('{"path":"/backend/database/explain.html","title":"SQL 语句执行计划分析","lang":"zh-CN","frontmatter":{"title":"SQL 语句执行计划分析","date":"2023-08-23T00:00:00.000Z","author":"Cleaner","categories":["数据库"],"tags":["MySQL"],"description":"前言 由于工作中业务比较复杂，一条 SQL 查询语句通常会涉及多个表，加上某些表数据量庞大（百万、甚至千万），SQL 语句的执行效率就成为日常工作中重点关注的方面。同时作为后端开发人员，对 SQL 语句进行优化的能力也是必不可少的。 Explain 各字段含义 Explain 关键字可以查看 SQL 语句（适用 SELECT、INSERT、UPDATE...","head":[["meta",{"property":"og:url","content":"https://cleaner.love/backend/database/explain.html"}],["meta",{"property":"og:site_name","content":"Cleaner"}],["meta",{"property":"og:title","content":"SQL 语句执行计划分析"}],["meta",{"property":"og:description","content":"前言 由于工作中业务比较复杂，一条 SQL 查询语句通常会涉及多个表，加上某些表数据量庞大（百万、甚至千万），SQL 语句的执行效率就成为日常工作中重点关注的方面。同时作为后端开发人员，对 SQL 语句进行优化的能力也是必不可少的。 Explain 各字段含义 Explain 关键字可以查看 SQL 语句（适用 SELECT、INSERT、UPDATE..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-25T07:30:06.000Z"}],["meta",{"property":"article:author","content":"Cleaner"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2023-08-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-25T07:30:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SQL 语句执行计划分析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-25T07:30:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cleaner\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"Explain 各字段含义","slug":"explain-各字段含义","link":"#explain-各字段含义","children":[{"level":3,"title":"id","slug":"id","link":"#id","children":[]},{"level":3,"title":"select_type","slug":"select-type","link":"#select-type","children":[]},{"level":3,"title":"type","slug":"type","link":"#type","children":[]},{"level":3,"title":"Extra","slug":"extra","link":"#extra","children":[]}]},{"level":2,"title":"实战优化思路","slug":"实战优化思路","link":"#实战优化思路","children":[]}],"git":{"createdTime":1742887806000,"updatedTime":1742887806000,"contributors":[{"name":"Cleaner","username":"Cleaner","email":"1414984960@qq.com","commits":1,"url":"https://github.com/Cleaner"}]},"readingTime":{"minutes":6.96,"words":2087},"filePathRelative":"backend/database/explain.md","localizedDate":"2023年8月23日","excerpt":"<h2>前言</h2>\\n<p>由于工作中业务比较复杂，一条 SQL 查询语句通常会涉及多个表，加上某些表数据量庞大（百万、甚至千万），SQL 语句的执行效率就成为日常工作中重点关注的方面。同时作为后端开发人员，对 SQL 语句进行优化的能力也是必不可少的。</p>","autoDesc":true}');export{p as comp,k as data};
